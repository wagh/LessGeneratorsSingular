// LIB "control.lib";

< "Cauchy-Binet.sing";

///////////////////////////////////////
// Assumption: two elements in a row are coprime 
//
// Input: mxn matrix containing these coprime elements at [j,i] and
// [k,i] positions.
//
// Returns a matrix W such that in the product WM, the [j,i] entry is
// 1 and [k,i] entry is 0.
///////////////////////////////////////
proc row_completion_for_coprime_pair(matrix M, int i, int j, int k)
{
    ideal I = M[j,i],M[k,i];
    I = std(I);
    poly tmp = reduce(1,I);
    if (tmp <> 0)
    {
        "Wrong input";
        return(0);
    }
    // matrix M [1][2] = V[i],V[j];
    int m = nrows(M);
    int n = ncols(M);
    
    matrix rtInv = rightInverse(module(M[j,i],M[k,i])); 
    // W = dsum(W,unitmat(n-2));
    matrix W = unitmat(m);
    W[j,j] = rtInv[1,1];
    W[j,k] = rtInv[2,1];
    W[k,j] = -M[k,i];
    W[k,k] = M[j,i];

    // print(W*M);
    // "-----------------------";
    // "";
    
    int s,t;
    matrix newMat[m-1][n-1];
    // "newMat",size_Matrix(newMat);
    // "W*M",size_Matrix(W*M);
    // "M",size_Matrix(M);
    // "W",size_Matrix(W);
    
    
    // for (s=1;s<=n;s++)
    // {
    //     if ( s< i )
    //     {
    //         for (t=1;t<=n;t++)
    //         {
    //             if ( t<j )
    //             {
    //                 s,t;
    //                 newMat[t,s] = M[t,s] - M[j,s]*M[t,i];
    //             }
    //             else
    //             {
    //                 if ( t>j )
    //                 {
    //                     s,t;
    //                     newMat[t-1,s] = M[t,s] - M[j,s]*M[t,i];
    //                 }
    //             }
    //         }
    //     }
    //     else
    //     {
    //         if ( s>i )
    //         {
    //             for (t=1;t<=n;t++)
    //             {
                    
    //                 if ( t<j )
    //                 {
    //                     s,t;
    //                     newMat[t,s-1] = M[t,s] - M[j,s]*M[t,i];
    //                 }
    //                 else 
    //                 {
    //                     if ( t>j )
    //                     {
    //                         s,t,j,i,"Here";
    //                             // s,t;
    //                             //newMat[t-1,s-1] = 
    //                         M[t,s];// - M[j,s]*M[t,i];
    //                     }
    //                 }
    //             }
    //         }
    //     }
    // }


    for (s=1;s<=n;s++)
    {
        if (s<i)
        {
            for(t=1;t<=m,t<>j;t++)
            {
                if (t<j)
                {
                    newMat[t,s] = M[t,s] - M[t,i]*M[j,s];
                }
                if (t>j)
                {
                    newMat[t-1,s] = M[t,s] - M[t,i]*M[j,s];
                }                    
            }
        }
        if (s>i)
        {
            for(t=1;t<=m,t<>j;t++)
            {
                if (t<j)
                {
                    newMat[t,s-1] = M[t,s] - M[t,i]*M[j,s];
                }
                if (t>j)
                {
                    newMat[t-1,s-1] = M[t,s] - M[t,i]*M[j,s];
                }                    
            }
        }
    }
    return(newMat);
}


///////////////////////////////////////
// Input: nxm matrix
// Returns a list three integers: i,j1,j2
// such that M[j1,i] & M[j2,i] are coprime
///////////////////////////////////////
proc scan_coprime(matrix M)
{
    int i,j,k;
    int m = nrows(M);
    int n = ncols(M);
    ideal I;
    
    for (i=1;i<=n;i++)
    {
        for(j=1;j<m;j++)
        {
            for(k=j+1;k<=m;k++)
            {
                I = M[j,i],M[k,i];
                I = std(I);
                if (reduce(1,I) == 0)
                {
                    return(i,j,k);
                }
            }
        }
    }
    return(0);
}

ring R = 0,(x,y,z),dp;
poly f = 3x2y2+3xy2+12;
poly g = 3x2y2+3xy2+11;

matrix M = sparsematrix(4,5,1);
M[1,1]=f;
M[3,1]=g;
print(M);
"===========";
"";


list l = scan_coprime(M);
// "l=",l;
if (l[1]<>0)
{
    matrix W = row_completion_for_coprime_pair(M,l[1],l[2],l[3]);
    print(W);
    "";
    "----------";
        // print(rm_unitcol(W*M));
    "";
}
else
{
    "There is no row which contains coprime elements.";
}
