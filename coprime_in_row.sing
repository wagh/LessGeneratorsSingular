LIB "control.lib";

///////////////////////////////////////
// Assumption: two elements in a row are coprime 
//
// Input: mxn matrix containing these coprime elements at [j,i] and
// [k,i] positions.
//
// Returns a matrix W such that in the product WM, the [j,i] entry is
// 1 and [k,i] entry is 0.
///////////////////////////////////////
proc row_completion_for_coprime_pair(matrix M, int i, int j, int k)
{
    ideal I = M[j,i],M[k,i];
    I = std(I);
    poly tmp = reduce(1,I);
    if (tmp <> 0)
    {
        "Wrong input";
        return(0);
    }
    // matrix M [1][2] = V[i],V[j];
    int m = nrows(M);
    int n = ncols(M);
    
    matrix rtInv = rightInverse(module(M[j,i],M[k,i])); 
    // W = dsum(W,unitmat(n-2));
    matrix W = unitmat(m);
    W[j,j] = rtInv[1,1];
    W[j,k] = rtInv[2,1];
    W[k,j] = -M[k,i];
    W[k,k] = M[j,i];

    print(W*M);
    "-----------------------";
    "";
    
    int s,t;
    matrix newMat[m-1][n-1];
    
    for (s=1;s<=n;s++)
    {
        if ( s< i )
        {
            for (t=1;t<=n;t++)
            {
                if ( t<j )
                {
                    s,t;
                    newMat[s,t] = M[t,s] - M[j,s]*M[t,i];
                }
                else
                {
                    if ( t>j )
                    {
                        s,t;
                        newMat[s,t-1] = M[t,s] - M[j,s]*M[t,i];
                    }
                }
            }
        }
        else
        {
            if ( s>i )
            {
                for (t=1;t<=n;t++)
                {
                    if ( t<j )
                    {
                        s,t;
                        newMat[s-1,t] = M[t,s] - M[j,s]*M[t,i];
                    }
                    else 
                    {
                        if ( t<j )
                        {
                            s,t;
                            newMat[s-1,t-1] = M[t,s] - M[j,s]*M[t,i];
                        }
                    }
                }
            }
        }
    }
        
    return(newMat);
}


///////////////////////////////////////
// Input: nxm matrix
// Returns a list three integers: i,j1,j2
// such that M[j1,i] & M[j2,i] are coprime
///////////////////////////////////////
proc scan_coprime(matrix M)
{
    int i,j,k;
    int m = nrows(M);
    int n = ncols(M);
    ideal I;
    
    for (i=1;i<=n;i++)
    {
        for(j=1;j<m;j++)
        {
            for(k=j+1;k<=m;k++)
            {
                I = M[j,i],M[k,i];
                I = std(I);
                if (reduce(1,I) == 0)
                {
                    return(i,j,k);
                }
            }
        }
    }
    return(0);
}

ring R = 0,(x,y,z),dp;
poly f = 3x2y2+3xy2+12;
poly g = 3x2y2+3xy2+11;

matrix M = sparsematrix(4,5,1);
M[1,1]=f;
M[3,1]=g;
print(M);
"===========";
"";


list l = scan_coprime(M);
// "l=",l;
if (l[1]<>0)
{
    matrix W = row_completion_for_coprime_pair(M,l[1],l[2],l[3]);
    print(W);
    "";
    "----------";
        // print(rm_unitcol(W*M));
    "";
}
else
{
    "There is no row which contains coprime elements.";
}
