///////////////////////////////////////////////////////////////////////////////
version="$Id: vinay.lib 0001 2012-06-11 16:00:00Z VInay $";
category = "";
info="
LIBRARY:  Vinay.lib   Loads  vinay.lib libraries (commutative case)

use: help Singular libraries; for a list of the libraries

AUTHORS:  VInay Wagh,         	  vinay_wagh@yahoo.com
@*        Mohmmed Barakat,        barakat@mathematik.uni-kl.de


Procedures:
size_matrix(M);		Returns the size of the matrix in \"m x n\" format. This is just for the display.
CauchyBinetRow(M);	Returns the unimodular completion of (n-1)xn matrix.
invtble_elt_in_matrix(matrix M)        Returns the matrix W when the row contains an invertible element
invtble_elt_in_unimodular_row(matrix M)        Returns the completion of the unimodular row when the row contains an invertible element
scan_coprime(matrix M)     Returns a list three integers: i,j1,j2 such that M[j1,i] & M[j2,i] are coprime
row_completion_for_coprime_pair(matrix M, int i, int j, int k)      two elements in a row are coprime 
get_unit_pos(matrix M)    Returns a list i,j such that M[i,j] is a unit.
delete_i_th_row(matrix M,int i)         Deletes i-th row of the matrix M and returns the submatrix.
complete_cleanup(matrix M)    Does a iterative cleanup of the given matrix, until there are no units in the matrix.
cleanup(matrix M, int p, int q)     cleanup of the given matrix, where M[p,q] entry is a unit.
isomorphism_matrix_new_to_old(list lst_row_num_deleted, int n)      Gives isomorphism from new module to old.
isomorphism_matrix_old_to_new(list lst_row_num_deleted, list lst_col_num_deleted, list lst_cols_deleted, int m)       Gives isomorphism from old module to new.


";


LIB "matrix.lib";

///////////////////////////////////////////////////////////////////////////////


///////////////////////////////////////
// Returns the size of a matrix 
// in the format: "r x c"
// Warning: The output is a string.
///////////////////////////////////////
proc size_Matrix(matrix M)
{
    if (typeof(M) <> "matrix")
    {
        return("Use size function\n The input should be of the type matrix");
    }
    return(string(nrows(M))+" x "+string(ncols(M)));
}


///////////////////////////////////////
// Module M is a rank 1 projective module.
// M is given by (n-1)xn matrix
//
// The procedure a returns a row which gives an isomorphism from the
// cokernel of the given matrix (i.e. rank 1 proj modules generated by
// n non-free generators) to the free module of rank 1. The right
// inverse of this row is the matrix of inverse isomorphism or
// equivalently the free generator of the corresponding free module.
///////////////////////////////////////
proc CauchyBinetRow(matrix M)
{
    int n = nrows(M);
    int i;
    intvec v,w;
    matrix M_i[n-1][n-1];
    matrix CB_completion[1][n];

    w = 1..n-1;

// For i = 1
    v = 2..n;
    M_i = submat(M,v,w);
    CB_completion[1,1] = (-1)^(n+1)*det(M_i);

// For i = n
    v = 1..n-1;
    M_i = submat(M,v,w);
    CB_completion[1,n] = (-1)^(n+n)*det(M_i);

// For 1<i<n    
    for (i=2;i<n;i++)
    {
        v = 1..i-1,i+1..n;
        M_i = submat(M,v,w);
        CB_completion[1,i] = (-1)^(n+i)*det(M_i);
    }
    
    return(CB_completion);
}



///////////////////////////////////////
// Returns the matrix W 
// Assumption: The row contains an invertible element (element from 
// the basefield)
///////////////////////////////////////
// Input: matrix M of size mxn
// Assume at least one of the M[i] is invertible
///////////////////////////////////////
proc invtble_elt_in_matrix(matrix M)
{
    string s = charstr(basering);
    int m = nrows(M);    
    int n = ncols(M);    
    int i,j,k,l;
    matrix ltInv[1][1];
    matrix newMat[m-1][n-1];

    list ij = get_unit_pos(M);

    if (size(ij) == 1)
    {
        "The proc is for the row with at least one invertible element";
        return(0);
    }
    
    i = ij[1];
    j = ij[2];
    
    
    for (k=1;k<i,k<>i;k++)
    {
        for (l=1;l<j;l++)
        {
            newMat[k,l] = M[k,l] - M[k,j]/M[i,j];
        }
        for (l=j+1;l<=n;l++)
        {
            newMat[k,l-1] = M[k,l] - M[k,j]/M[i,j];
        }
    }
    
    for (k=i+1;k<=m;k++)
    {
        for (l=1;l<j;l++)
        {
            newMat[k-1,l] = M[k,l] - M[k,j]/M[i,j];
        }
        for (l=j+1;l<=n;l++)
        {
            newMat[k-1,l-1] = M[k,l] - M[k,j]/M[i,j];
        }
    }
    return(newMat);
}



///////////////////////////////////////
// Returns the matrix W
// Assumption: The row contains an invertible element (element from 
// the basefield)
///////////////////////////////////////
// Input: matrix M of size 1xn
// Assume at least one of the M[i] is invertible
///////////////////////////////////////
proc invtble_elt_in_unimodular_row(matrix M)
{
    string s = charstr(basering);
    int n = ncols(M);    
    int i,j;

    list ij = get_unit_pos(submat(M[1,1..n]));

    if (size(ij) == 1)
    {
        j=ij[2];
        return(dsum(1/M[1,j], unitmat(n-1)));
    }
    else
    {
        "The proc is for the row with at least one invertible element";
        return(0);
    }
}


///////////////////////////////////////
// Input: nxm matrix
// Returns a list three integers: i,j1,j2
// such that M[j1,i] & M[j2,i] are coprime
///////////////////////////////////////
proc scan_coprime(matrix M)
{
    int i,j,k;
    int m = nrows(M);
    int n = ncols(M);
    ideal I;
    
    for (i=1;i<=n;i++)
    {
        for(j=1;j<m;j++)
        {
            for(k=j+1;k<=m;k++)
            {
                I = M[j,i],M[k,i];
                I = std(I);
                if (reduce(1,I) == 0)
                {
                    return(i,j,k);
                }
            }
        }
    }
    return(0);
}




///////////////////////////////////////
// Input: Matrix M (size m x n) Returns a list of two integers i,j
// such that M[i,j] is a unit.
// 
// The proc ends after encountering the first unit. The search is done
// column-wise.
//
// If no unit found, then returns a string.  
//
//Separate cases for basering to be integers or a field.
///////////////////////////////////////
proc get_unit_pos(matrix M)
{
    int m = nrows(M);
    int n = ncols(M);

    int i,j;
    string s = charstr(basering);

    if (find("integer",s) == 0)
    {
        for (j=1;j<=n;j++)
        {
            for (i=1;i<=m;i++)
            {
                if (deg(M[i,j]) == 0)
                {
                    return(i,j);
                }
            }
        }
        // "The matrix does not contain an invertible element";
        return(0);
    }
    else
    {
        for (j=1;j<=n;j++)
        {
            for (i=1;i<=m;i++)
            {
                if ((M[i,j] == 1) || (M[i,j] == -1))
                {
                    return(i,j);
                }
            }
        }        
        // "The matrix does not contain an invertible element";
        return(0);
    }
}



/////////////////////////////////////
// Does a cleanup of the given matrix
//
// INPUT: mxn matrix with at least one entry 1
//
// OUTPUT: A list
// 1. matrix of size (m-1)x(n-1) or smaller. 
// 2. The deleted column multiplied by unit inverse (without 1)
// 3. The deleted row multiplied by unit inverse (without 1)
//
/////////////////////////////////////
proc cleanup(matrix M, int p, int q)
{
    int m = nrows(M);
    int n = ncols(M);
    int i,j;
    matrix MM[m-1][n-1];
    list tmp_list;
    intvec tmp_vec,r,c;
    matrix e[1][1];
    
    e = 1/M[p,q];
    
    tmp_vec = 1..m;
    tmp_list = list(tmp_vec[1..size(tmp_vec)]);
    tmp_list = delete(tmp_list,p);

    for (i=1;i<=size(tmp_list);i++)
    {
        r[i]=tmp_list[i];
    }

    tmp_vec = 1..n;
    tmp_list = list(tmp_vec[1..size(tmp_vec)]);
    tmp_list = delete(tmp_list,q);

    for (i=1;i<=size(tmp_list);i++)
    {
        c[i]=tmp_list[i];
    }
    
    matrix pivotCol[m-1][1] = submat(M,r,q);
    matrix pivotRow[1][n-1] = submat(M,p,c);
    
    // MM = submat(M,r,c) - 1/M[p,q]*submat(M,r,q)*submat(M,p,c);

    // Changed this to cater the non-commutative case.
    // MM = submat(M,r,c) - 1/M[p,q]*pivotCol*pivotRow;
    MM = submat(M,r,c) - pivotCol*e*pivotRow;

    return(MM, 1/M[p,q]*pivotCol, 1/M[p,q]*pivotRow);    
    // return(MM);
}

/////////////////////////////////////
// Does a iterative cleanup of the given matrix, until there are no
// units in the matrix.
//
// INPUT: mxn matrix with at least one entry 1
//
// OUTPUT: A list 
// 1. cleaned up matrix without any units
// 2. a list of column numbers which were deleted during the proc. 
//
// Warning: The above list may contain repeated numbers. It just means
// that first you delete lst_rows_deleted[1] column from Identity
// matrix, then delete lst_rows_deleted[2] column from the resulting
// matrix and so on.
//
// Warning 2: In case of any change in the output format, inform
// Mohamed IMMEDIATELY. The GAP code depends on this output.
//
// Warning 3: Suppose at some iteration M is just a column matrix and
// get_uni_pos returns nontrivial answer, then this proc returns a
// string "The output is an empty matrix." BE CAREFUL WHILE CALLING
// THIS PROC.
//
// The worst case example: try to cleanup a matrix with all entries to
// be unit.
/////////////////////////////////////
proc complete_cleanup(matrix M)
{
    list ij;
    int p,q;
    int IS_CLEAN=0;
    list lst_rows_deleted, lst_cols_deleted,lst_row_num_deleted, lst_col_num_deleted, lst_unit;
    int m,n;
    list l;
    

    while(IS_CLEAN<>1)
    {
        m = nrows(M);
        n = ncols(M);
    
        ij = get_unit_pos(M);
        if (size(ij) == 1)
        {
            // "No cleanup possible";
            // "Returning the original matrix";
            IS_CLEAN=1;
            return(M, lst_row_num_deleted, lst_col_num_deleted, lst_rows_deleted, lst_cols_deleted);
        }
        if (m==1 || n==1)
        {
            return("The output is an empty matrix.");
        }
        p = ij[1];
        q = ij[2];
        lst_row_num_deleted[size(lst_row_num_deleted)+1] = p;
        lst_col_num_deleted[size(lst_col_num_deleted)+1] = q;
        
        // No need to divide by the unit here, as it is already being
        // taken care of in the return value of cleanup()
        
        // lst_rows_deleted[size(lst_rows_deleted)+1] = 1/M[p,q]*submat(M,1..m,q);
        // lst_cols_deleted[size(lst_cols_deleted)+1] = 1/M[p,q]*submat(M,p,1..n);

        l = cleanup(M,p,q);
        M = l[1];
        lst_cols_deleted[size(lst_cols_deleted)+1] = -l[2];
        lst_rows_deleted[size(lst_rows_deleted)+1] = -l[3];     
    }
}



/////////////////////////////////////
// Deletes i-th row of the matrix M and returns the submatrix.
/////////////////////////////////////
proc delete_i_th_row(matrix M, int i)
{
    int m = nrows(M);
    int n = ncols(M);
    list tmp_list;
    intvec r, tmp_vec;
    int j;
    
    tmp_vec = 1..m;
    tmp_list = list(tmp_vec[1..size(tmp_vec)]);
    tmp_list = delete(tmp_list,i);

    for (j=1;j<=size(tmp_list);j++)
    {
        r[j]=tmp_list[j];
    }
    return(submat(M,r,1..n));
}



/////////////////////////////////////
// This proc gives the isomorphism matrix by deleting the
// corresponding columns from the identity matrix. The list
// lst_rows_deleted tells (sequentially) which columns are to be
// deleted.  
// 
// Warning: The above list may contain repeated numbers. It just means
// that first you delete lst_rows_deleted[1] column from I, then
// delete lst_rows_deleted[2] column from the result and so on.  
//
// The second parameter n is the number of columns of the original
// matrix.
//
// Warning: Should not be called if cleanup has returned an empty
// matrix. In that case isomorphism matrix is also an empty matrix.
/////////////////////////////////////
proc isomorphism_matrix_new_to_old(list lst_row_num_deleted, int n)
{
    matrix UI = unitmat(n);
    int i;

    for (i=1;i<=size(lst_row_num_deleted);i++)
    {
        UI = delete_i_th_row(UI,lst_row_num_deleted[i]);
    }
//    return(transpose(M));
    return(UI);
}

////////////////////////////////////
// This proc gives the isomorphism from old module to the new
// module. Returns the matrix U such that UM = N, where M is the
// original matrix and N is the cleanup of M. 
// 
// Note that this means the column space generated by UM is same as
// column space generated by N.
//
// The inverse isomorphism is gen by UI, which can be obtained by
// deleting apropriate rows from the identity matrix using proc
// isomorphism_matrix_new_to_old.
//
// m = nrows of the original matrix
////////////////////////////////////
proc isomorphism_matrix_old_to_new(list lst_row_num_deleted, list lst_col_num_deleted, list lst_cols_deleted, int m)
{
    matrix id = unitmat(1);
    int i,j;
    intvec v,w;
    list lst_id_mat;

    for(i=1;i<=size(lst_col_num_deleted);i++)
    {
        id=unitmat(m-i+1);
        id = delete_i_th_row(id,lst_row_num_deleted[i]);
        
        for(j=1;j<=nrows(lst_cols_deleted[i]);j++)
        {
            id[j,lst_row_num_deleted[i]] = lst_cols_deleted[i][j,1];
        }
        lst_id_mat[i] = id;
    }
    matrix U = unitmat(m);
    for (i=1;i<=size(lst_id_mat);i++)
    {
        U = lst_id_mat[i] * U;
    }
    return(U);
}
