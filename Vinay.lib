///////////////////////////////////////////////////////////////////////////////
version="$Id: vinay.lib 0001 2012-06-11 16:00:00Z VInay $";
category = "";
info="
LIBRARY:  Vinay.lib   Loads  vinay.lib libraries (commutative case)

use: help Singular libraries; for a list of the libraries

AUTHORS:  VInay Wagh,         	  vinay_wagh@yahoo.com
@*        Mohmmed Barakat,        barakat@mathematik.uni-kl.de


Procedures:
size_matrix(M);		Returns the size of the matrix in \"m x n\" format. This is just for the display.
CauchyBinetRow(M);	Returns the unimodular completion of (n-1)xn matrix.
scan_coprime(matrix M)     Returns a list three integers: i,j1,j2 such that M[j1,i] & M[j2,i] are coprime
row_completion_for_coprime_pair(matrix M, int i, int j, int k)      two elements in a row are coprime 
get_unit_pos(matrix M)    Returns a list i,j such that M[i,j] is a unit.
delete_i_th_row(matrix M,int i)         Deletes i-th row of the matrix M and returns the submatrix.
complete_cleanup(matrix M)    Does a iterative cleanup of the given matrix, until there are no units in the matrix.
cleanup(matrix M, int p, int q)     cleanup of the given matrix, where M[p,q] entry is a unit.
isomorphism_matrix_new_to_old(list lst_row_num_deleted, int n)      Gives isomorphism from new module to old.
isomorphism_matrix_old_to_new(list lst_row_num_deleted, list lst_col_num_deleted, list lst_cols_deleted, int m)       Gives isomorphism from old module to new.
generate_random_unimod_matrix(int n)       generates n x n unimodular matrix with random entries.
find_column_except_1_elt_generate_unit(matrix M)      gives position (i,j) such that all but (i,j)-th element of j-th column generate 1
column_except_1_elt_generate_unit(M, i, j, column_ideal)       Matrix W s.t. W*M has 1 in (i,j)-th position
find_row_except_1_elt_generate_unit(matrix M)      gives position (i,j) such that all but (i,j)-th element of i-th row generate 1
row_except_1_elt_generate_unit(M, i, j, column_ideal)       Matrix W s.t. W*M has 1 in (i,j)-th position




";


LIB "matrix.lib";

///////////////////////////////////////////////////////////////////////////////


///////////////////////////////////////
// Returns the size of a matrix 
// in the format: "r x c"
// Warning: The output is a string.
///////////////////////////////////////
proc size_Matrix(matrix M)
{
    if (typeof(M) <> "matrix")
    {
        return("Use size function\n The input should be of the type matrix");
    }
    return(string(nrows(M))+" x "+string(ncols(M)));
}


///////////////////////////////////////
// Module M is a rank 1 projective module.
// M is given by (n-1)xn matrix
//
// The procedure a returns a row which gives an isomorphism from the
// cokernel of the given matrix (i.e. rank 1 proj modules generated by
// n non-free generators) to the free module of rank 1. The right
// inverse of this row is the matrix of inverse isomorphism or
// equivalently the free generator of the corresponding free module.
///////////////////////////////////////
proc CauchyBinetRow(matrix M)
{
    int n = nrows(M);
    int i;
    intvec v,w;
    matrix M_i[n-1][n-1];
    matrix CB_completion[1][n];

    w = 1..n-1;

// For i = 1
    v = 2..n;
    M_i = submat(M,v,w);
    CB_completion[1,1] = (-1)^(n+1)*det(M_i);

// For i = n
    v = 1..n-1;
    M_i = submat(M,v,w);
    CB_completion[1,n] = (-1)^(n+n)*det(M_i);

// For 1<i<n    
    for (i=2;i<n;i++)
    {
        v = 1..i-1,i+1..n;
        M_i = submat(M,v,w);
        CB_completion[1,i] = (-1)^(n+i)*det(M_i);
    }
    
    return(CB_completion);
}


///////////////////////////////////////
// Input: nxm matrix
// Returns a list three integers: i1,i2,j
// such that M[i1,j] & M[i2,j] are coprime
///////////////////////////////////////
proc scan_coprime_column(matrix M)
{
    int i,j,k;
    int m = nrows(M);
    int n = ncols(M);
    ideal I;
    
    for (j=1;j<=n;j++)
    {
        for(i1=1;i1<m;i1++)
        {
            for(i2=i1+1;i2<=m;i2++)
            {
                I = M[i1,j],M[i2,j];
                I = std(I);
                if (reduce(1,I) == 0)
                {
                    return(i1,i2,j);
                }
            }
        }
    }
    return(0);
}

///////////////////////////////////////
// Input: nxm matrix
// Returns a list three integers: i,j1,j2
// such that M[i,j1] & M[i,j2] are coprime
///////////////////////////////////////
proc scan_coprime_row(matrix M)
{
    int i,j,k;
    int m = nrows(M);
    int n = ncols(M);
    ideal I;
    
    for (i=1;i<=n;i++)
    {
        for(j1=1;j1<m;j1++)
        {
            for(j2=j1+1;j2<=m;j2++)
            {
                I = M[i,j1],M[i,j2];
                I = std(I);
                if (reduce(1,I) == 0)
                {
                    return(i,j1,j2);
                }
            }
        }
    }
    return(0);
}




///////////////////////////////////////
// Input: Matrix M (size m x n) Returns a list of two integers i,j
// such that M[i,j] is a unit.
// 
// The proc ends after encountering the first unit. The search is done
// column-wise.
//
// If no unit found, then returns a string.  
//
//Separate cases for basering to be integers or a field.
///////////////////////////////////////
proc get_unit_pos(matrix M)
{
    int m = nrows(M);
    int n = ncols(M);

    int i,j;
    string s = charstr(basering);

    if (find("integer",s) == 0)
    {
        for (j=1;j<=n;j++)
        {
            for (i=1;i<=m;i++)
            {
                if (deg(M[i,j]) == 0)
                {
                    return(i,j);
                }
            }
        }
        // "The matrix does not contain an invertible element";
        return(0);
    }
    else
    {
        for (j=1;j<=n;j++)
        {
            for (i=1;i<=m;i++)
            {
                if ((M[i,j] == 1) || (M[i,j] == -1))
                {
                    return(i,j);
                }
            }
        }        
        // "The matrix does not contain an invertible element";
        return(0);
    }
}



/////////////////////////////////////
// Does a cleanup of the given matrix
//
// INPUT: mxn matrix with at least one entry 1
//
// OUTPUT: A list
// 1. matrix of size (m-1)x(n-1) or smaller. 
// 2. The deleted column multiplied by unit inverse (without 1)
// 3. The deleted row multiplied by unit inverse (without 1)
//
/////////////////////////////////////
proc cleanup(matrix M, int p, int q)
{
    int m = nrows(M);
    int n = ncols(M);
    int i,j;
    matrix MM[m-1][n-1];
    list tmp_list;
    intvec tmp_vec,r,c;
    matrix e[1][1];
    
    e = 1/M[p,q];
    
    tmp_vec = 1..m;
    tmp_list = list(tmp_vec[1..size(tmp_vec)]);
    tmp_list = delete(tmp_list,p);

    for (i=1;i<=size(tmp_list);i++)
    {
        r[i]=tmp_list[i];
    }

    tmp_vec = 1..n;
    tmp_list = list(tmp_vec[1..size(tmp_vec)]);
    tmp_list = delete(tmp_list,q);

    for (i=1;i<=size(tmp_list);i++)
    {
        c[i]=tmp_list[i];
    }
    
    matrix pivotCol[m-1][1] = submat(M,r,q);
    matrix pivotRow[1][n-1] = submat(M,p,c);
    
    // MM = submat(M,r,c) - 1/M[p,q]*submat(M,r,q)*submat(M,p,c);

    // Changed this to cater the non-commutative case.
    // MM = submat(M,r,c) - 1/M[p,q]*pivotCol*pivotRow;
    MM = submat(M,r,c) - pivotCol*e*pivotRow;

    return(MM, pivotCol*e, e*pivotRow);    
    // return(MM);
}

/////////////////////////////////////
// Does a iterative cleanup of the given matrix, until there are no
// units in the matrix.
//
// INPUT: mxn matrix with at least one entry 1
//
// OUTPUT: A list 
// 1. cleaned up matrix without any units
// 2. a list of column numbers which were deleted during the proc. 
//
// Warning: The above list may contain repeated numbers. It just means
// that first you delete lst_rows_deleted[1] column from Identity
// matrix, then delete lst_rows_deleted[2] column from the resulting
// matrix and so on.
//
// Warning 2: In case of any change in the output format, inform
// Mohamed IMMEDIATELY. The GAP code depends on this output.
//
// Warning 3: Suppose at some iteration M is just a column matrix and
// get_uni_pos returns nontrivial answer, then this proc returns a
// string "The output is an empty matrix." BE CAREFUL WHILE CALLING
// THIS PROC.
//
// The worst case example: try to cleanup a matrix with all entries to
// be unit.
/////////////////////////////////////
proc complete_cleanup(matrix M)
{
    list ij;
    int p,q;
    int IS_CLEAN=0;
    list lst_rows_deleted, lst_cols_deleted,lst_row_num_deleted, lst_col_num_deleted, lst_unit;
    int m,n;
    list l;
    

    while(IS_CLEAN<>1)
    {
        m = nrows(M);
        n = ncols(M);
    
        ij = get_unit_pos(M);
        if (size(ij) == 1)
        {
            // "No cleanup possible";
            // "Returning the original matrix";
            IS_CLEAN=1;
            return(M, lst_row_num_deleted, lst_col_num_deleted, lst_rows_deleted, lst_cols_deleted);
        }
        if (m==1 || n==1)
        {
            return("The output is an empty matrix.");
        }
        p = ij[1];
        q = ij[2];
        lst_row_num_deleted[size(lst_row_num_deleted)+1] = p;
        lst_col_num_deleted[size(lst_col_num_deleted)+1] = q;
        
        // No need to divide by the unit here, as it is already being
        // taken care of in the return value of cleanup()
        
        // lst_rows_deleted[size(lst_rows_deleted)+1] = 1/M[p,q]*submat(M,1..m,q);
        // lst_cols_deleted[size(lst_cols_deleted)+1] = 1/M[p,q]*submat(M,p,1..n);

        l = cleanup(M,p,q);
        M = l[1];
        lst_cols_deleted[size(lst_cols_deleted)+1] = -l[2];
        lst_rows_deleted[size(lst_rows_deleted)+1] = -l[3];     
    }
}



/////////////////////////////////////
// Deletes i-th row of the matrix M and returns the submatrix.
/////////////////////////////////////
proc delete_i_th_row(matrix M, int i)
{
    int m = nrows(M);
    int n = ncols(M);
    list tmp_list;
    intvec r, tmp_vec;
    int j;
    
    tmp_vec = 1..m;
    tmp_list = list(tmp_vec[1..size(tmp_vec)]);
    tmp_list = delete(tmp_list,i);

    for (j=1;j<=size(tmp_list);j++)
    {
        r[j]=tmp_list[j];
    }
    return(submat(M,r,1..n));
}



/////////////////////////////////////
// This proc gives the isomorphism matrix by deleting the
// corresponding columns from the identity matrix. The list
// lst_rows_deleted tells (sequentially) which columns are to be
// deleted.  
// 
// Warning: The above list may contain repeated numbers. It just means
// that first you delete lst_rows_deleted[1] column from I, then
// delete lst_rows_deleted[2] column from the result and so on.  
//
// The second parameter n is the number of columns of the original
// matrix.
//
// Warning: Should not be called if cleanup has returned an empty
// matrix. In that case isomorphism matrix is also an empty matrix.
/////////////////////////////////////
proc isomorphism_matrix_new_to_old(list lst_row_num_deleted, int n)
{
    matrix UI = unitmat(n);
    int i;

    for (i=1;i<=size(lst_row_num_deleted);i++)
    {
        UI = delete_i_th_row(UI,lst_row_num_deleted[i]);
    }
//    return(transpose(M));
    return(UI);
}

////////////////////////////////////
// This proc gives the isomorphism from old module to the new
// module. Returns the matrix U such that UM = N, where M is the
// original matrix and N is the cleanup of M. 
// 
// Note that this means the column space generated by UM is same as
// column space generated by N.
//
// The inverse isomorphism is gen by UI, which can be obtained by
// deleting apropriate rows from the identity matrix using proc
// isomorphism_matrix_new_to_old.
//
// m = nrows of the original matrix
////////////////////////////////////
proc isomorphism_matrix_old_to_new(list lst_row_num_deleted, list lst_col_num_deleted, list lst_cols_deleted, int m)
{
    matrix id = unitmat(1);
    int i,j;
    intvec v,w;
    list lst_id_mat;

    for(i=1;i<=size(lst_col_num_deleted);i++)
    {
        id=unitmat(m-i+1);
        id = delete_i_th_row(id,lst_row_num_deleted[i]);
        
        for(j=1;j<=nrows(lst_cols_deleted[i]);j++)
        {
            id[j,lst_row_num_deleted[i]] = lst_cols_deleted[i][j,1];
        }
        lst_id_mat[i] = id;
    }
    matrix U = unitmat(m);
    for (i=1;i<=size(lst_id_mat);i++)
    {
        U = lst_id_mat[i] * U;
    }
    return(U);
}



//////////////////////////////////
// This generates n x n unimodular matrix with random entries.
//////////////////////////////////
proc generate_random_unimod_matrix(int n)
{
    int i,j;
    matrix M[n][n];
    
    for (i=1;i<=n;i++)
    {
        M[i,i] = random(1,10);// sparsepoly(0,0,0,3);
    }
    for (i=1;i<=n;i++)
    {
        for (j=1;j<i;j++)
        {
            M[i,j] = sparsepoly(0,1,75,3);
        }
    }
    return(transpose(M)*M);
}



////////////////////////////////
// Input: mxn matrix M, 
//
// Output: int i, int j such that (n-1)-elements of j-th column,
// namely all elements except [i,j]-th entry generate 1 and the ideal
// row_id generated by these (n-1) elements.
////////////////////////////////
proc find_column_except_1_elt_generate_unit(matrix M)
{
    int i,j,t;
    int m,n;
    m = nrows(M);
    n = ncols(M);

    intvec v,w;
    list l;
    ideal column_id;
    
    for (j=1;j<=m;j++)          // Column No.
    {
        for (i=1;i<=n;i++)      // Row No.
        {
            v = 1..m;
            l = list(v[1..m]);
            l = delete(l,i);
            for (t=1;t<=size(l);t++)
            {
                w[t]=l[t];
            }
            
            column_id = ideal(submat(M,w,j));
            // column_id = std(column_id); // These two steps are needed as I
            //                       // am not sure whether std bit is
            //                       // set properly if you combine the
            //                       // two steps. (Ref: Singular trac
            //                       // tkt 428)
            if (reduce(1,std(column_id)) == 0)
            {
                return(i, j, column_id);
            }
        }
    }
    return("The matrix is not unimodular.");
}



////////////////////////////////
// Input: mxn matrix M, int i, int j such that (n-1)-elements of j-th
// column, namely all elements except [i,j]-th entry generate the unit
// matrix.
//
// Output: Matrix of transformation W, such that W*j-th column of M
// makes 1 in (i,j)-th position.
////////////////////////////////

proc column_except_1_elt_generate_unit(matrix M, int i, int j, ideal column_ideal)
{
    int k,l;
    int n = ncols(M);
    
    matrix W = unitmat(n);
    matrix G = rightInverse(matrix(column_ideal)); // Need to compute right
                                           // inverse irrespective of
                                           // row or column
                                           // proc. Since typecast
                                           // from ideal to matrix
                                           // gives a row of which we
                                           // are finding right inverse.
    if (i == 1)
    {
        W[j,i]=1;
        
        for (k=2;k<=n;k++)
        {
            W[j,k] = (1-M[i,j])*G[k-1,1];
        }
        return(W);
    }

    if (i == n)
    {
        W[j,i]=1;
        for (k=1;k<=n-1;k++)
        {
            W[j,k] = (1-M[i,j])*G[k,1];
        }
        return(W);
    }
    for (k=1;k<=n;k++)
    {
        W[j,i]=1;
        if (k<i)
        {
            W[j,k] = (1-M[i,j])*G[k,1];
        }
        if (k>i)
        {
            W[j,k] = (1-M[i,j])*G[k-1,1];
        }
    }
    return(W);
}


////////////////////////////////
// Input: mxn matrix M, 
//
// Output: int i, int j such that (n-1)-elements of i-th row, namely
// all elements except [i,j]-th entry generate the unit matrix and the
// ideal row_id generated by these (n-1) elements.
//
////////////////////////////////

proc find_row_except_1_elt_generate_unit(matrix M)
{
    int i,j,t;
    int m,n;
    m = nrows(M);
    n = ncols(M);
    
    intvec v,w;
    list l;
    ideal row_id;
    
    for (i=1;i<=n;i++)      // Row No.
    {
        for (j=1;j<=m;j++)          // Column No.
        {
            v = 1..n;
            l = list(v[1..n]);
            l = delete(l,j);
            for (t=1;t<=size(l);t++)
            {
                w[t]=l[t];
            }
            
            row_id = ideal(submat(M,i,w));

            if (reduce(1,std(row_id)) == 0)
            {
                return(i, j, row_id);
            }
        }
    }
    return("The matrix is not unimodular.");
}



////////////////////////////////
// Input: mxn matrix M, int i, int j such that (n-1)-elements of i-th
// row, namely all elements except [i,j]-th entry generate the unit
// matrix.
//
////////////////////////////////

proc row_except_1_elt_generate_unit(matrix M, int i, int j, ideal row_ideal)
{
    int k,l;
    int m = nrows(M);
    
    matrix W = unitmat(m);
    matrix G = rightInverse(matrix(row_ideal)); // Need to compute right
        // inverse irrespective of
        // row or column
        // proc. Since typecast
        // from ideal to matrix
        // gives a row of which we
        // are finding right inverse.
    
    if (i == 1)
    {
        W[j,i]=1;

        for (k=2;k<=m;k++)
        {
            W[k,i] = G[k-1,1]*(1-M[i,j]);
        }
        return(W);
    }

    if (i == n)
    {
        W[j,i]=1;
        for (k=1;k<=m-1;k++)
        {
            W[k,i] = G[k,1]*(1-M[i,j]);
        }
        return(W);
    }
    for (k=1;k<=m;k++)
    {
        W[j,i]=1;
        if (k<j)
            {
                W[k,i] = G[k,1]*(1-M[i,j]);
            }
            if (k>j)
            {
                W[k,i] = G[k-1,1]*(1-M[i,j]);
            }
            }
        return(W);
    }



