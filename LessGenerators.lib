///////////////////////////////////////////////////////////////////////////////
version="$Id: vinay.lib 0001 2013-07-23 16:00:00Z VInay $";
category = "";
info="
LIBRARY:  LessGenerator.lib   Loads  LessGenerator.lib libraries (commutative case)

use: help Singular libraries; for a list of the libraries

AUTHORS:  VInay Wagh,         	  waghoba@gmail.com
@*        Mohmmed Barakat,        barakat@mathematik.uni-kl.de


Procedures:
// Heuristics
row_completion_for_coprime_pair(matrix M, int i, int j, int k)      two elements in a row are coprime 
column_except_1_elt_generate_unit(M, i, j, column_ideal)       Matrix W s.t. W*M has 1 in (i,j)-th position
row_except_1_elt_generate_unit(M, i, j, column_ideal)       Matrix W s.t. W*M has 1 in (i,j)-th position
column_having_left_inverse_containing_unit(matrix M)        finds a column which has left inverse containing a unit.
row_having_right_inverse_containing_unit(matrix M)        finds a row which has right inverse containing a unit.


// Tools
size_matrix(M);		Returns the size of the matrix in \"m x n\" format. This is just for the display.
scan_coprime(matrix M)     Returns a list three integers: i,j1,j2 such that M[j1,i] & M[j2,i] are coprime
get_unit_pos(matrix M)    Returns a list i,j such that M[i,j] is a unit.
delete_i_th_row(matrix M,int i)         Deletes i-th row of the matrix M and returns the submatrix.
generate_random_unimod_matrix(int n)       generates n x n unimodular matrix with random entries.
find_column_except_1_elt_generate_unit(matrix M)      gives position (i,j) such that all but (i,j)-th element of j-th column generate 1
find_row_except_1_elt_generate_unit(matrix M)      gives position (i,j) such that all but (i,j)-th element of i-th row generate 1
proc get_max_ideal_integers(ideal I,string s)       internal proc to compute max_id containing I over integers
proc get_max_ideal_zero(ideal I,string s)       internal proc to compute max_id containing I over Q
proc get_max_ideal_p(ideal I,string s)       internal proc to compute max_id containing I over field of char p


// Main procedures
CauchyBinetRow(M);	Returns the unimodular completion of (n-1)xn matrix.
complete_cleanup(matrix M)    Does a iterative cleanup of the given matrix, until there are no units in the matrix.
cleanup(matrix M, int p, int q)     cleanup of the given matrix, where M[p,q] entry is a unit.
isomorphism_matrix_new_to_old(list lst_row_num_deleted, int n)      Gives isomorphism from new module to old.
isomorphism_matrix_old_to_new(list lst_row_num_deleted, list lst_col_num_deleted, list lst_cols_deleted, int m)       Gives isomorphism from old module to new.
Suslin_Lemma(poly f, poly g, int var_pos, int unit_pos)      Given f, g with g_(unit_pos) is a unit wrt var(var_pos) it returns a poly with this unit as a leadcoeff.
is_local_unit(poly f, ideal max_id, int var_pos)         Checks if f is a unit in the localization wrt max_id of subring without var(var_pos) 
get_max_ideal(ideal I, intvec v)            Returns a maximal ideal of the ring k[lst_vars] containing ideal I

";


LIB "control.lib";
LIB "primdec.lib";
LIB "crypto.lib";               // To get the "next prime" in
                                // get_max_ideal proc.

///////////////////////////////////////////////////////////////////////////////


///////////////////////////////////////
// Returns the size of a matrix 
// in the format: "r x c"
// Warning: The output is a string.
///////////////////////////////////////
proc size_matrix(matrix M)
{
    if (typeof(M) <> "matrix")
    {
        return("Use size function\n The input should be of the type matrix");
    }
    return(string(nrows(M))+" x "+string(ncols(M)));
}


///////////////////////////////////////
// Module M is a rank 1 projective module.
// M is given by (n-1)xn matrix
//
// The procedure a returns a row which gives an isomorphism from the
// cokernel of the given matrix (i.e. rank 1 proj modules generated by
// n non-free generators) to the free module of rank 1. The right
// inverse of this row is the matrix of inverse isomorphism or
// equivalently the free generator of the corresponding free module.
///////////////////////////////////////
proc CauchyBinetRow(matrix M)
{
    int n = nrows(M);
    int i;
    intvec v,w;
    matrix M_i[n-1][n-1];
    matrix CB_completion[1][n];

    w = 1..n-1;

// For i = 1
    v = 2..n;
    M_i = submat(M,v,w);
    CB_completion[1,1] = (-1)^(n+1)*det(M_i);

// For i = n
    v = 1..n-1;
    M_i = submat(M,v,w);
    CB_completion[1,n] = (-1)^(n+n)*det(M_i);

// For 1<i<n    
    for (i=2;i<n;i++)
    {
        v = 1..i-1,i+1..n;
        M_i = submat(M,v,w);
        CB_completion[1,i] = (-1)^(n+i)*det(M_i);
    }
    
    return(CB_completion);
}


///////////////////////////////////////
// Input: nxm matrix
// Returns a list three integers: i1,i2,j
// such that M[i1,j] & M[i2,j] are coprime
///////////////////////////////////////
proc scan_coprime_column(matrix M)
{
    int i,j,k;
    int m = nrows(M);
    int n = ncols(M);
    ideal I;
    
    for (j=1;j<=n;j++)
    {
        for(i1=1;i1<m;i1++)
        {
            for(i2=i1+1;i2<=m;i2++)
            {
                I = M[i1,j],M[i2,j];
                I = std(I);
                if (reduce(1,I) == 0)
                {
                    return(i1,i2,j);
                }
            }
        }
    }
    return(0);
}

///////////////////////////////////////
// Input: nxm matrix
// Returns a list three integers: i,j1,j2
// such that M[i,j1] & M[i,j2] are coprime
///////////////////////////////////////
proc scan_coprime_row(matrix M)
{
    int i,j,k;
    int m = nrows(M);
    int n = ncols(M);
    ideal I;
    
    for (i=1;i<=n;i++)
    {
        for(j1=1;j1<m;j1++)
        {
            for(j2=j1+1;j2<=m;j2++)
            {
                I = M[i,j1],M[i,j2];
                I = std(I);
                if (reduce(1,I) == 0)
                {
                    return(i,j1,j2);
                }
            }
        }
    }
    return(0);
}




///////////////////////////////////////
// Input: Matrix M (size m x n) Returns a list of two integers i,j
// such that M[i,j] is a unit.
// 
// The proc ends after encountering the first unit. The search is done
// column-wise.
//
// If no unit found, then returns a string.  
//
//Separate cases for basering to be integers or a field.
///////////////////////////////////////
proc get_unit_pos(matrix M)
{
    int m = nrows(M);
    int n = ncols(M);

    int i,j;
    string s = charstr(basering);

    if (find("integer",s) == 0)
    {
        for (j=1;j<=n;j++)
        {
            for (i=1;i<=m;i++)
            {
                if (deg(M[i,j]) == 0)
                {
                    return(i,j);
                }
            }
        }
        // "The matrix does not contain an invertible element";
        return(0);
    }
    else
    {
        for (j=1;j<=n;j++)
        {
            for (i=1;i<=m;i++)
            {
                if ((M[i,j] == 1) || (M[i,j] == -1))
                {
                    return(i,j);
                }
            }
        }        
        // "The matrix does not contain an invertible element";
        return(0);
    }
}



/////////////////////////////////////
// Does a cleanup of the given matrix
//
// INPUT: mxn matrix with at least one entry 1
//
// OUTPUT: A list
// 1. matrix of size (m-1)x(n-1) or smaller. 
// 2. The deleted column multiplied by unit inverse (without 1)
// 3. The deleted row multiplied by unit inverse (without 1)
//
/////////////////////////////////////
proc cleanup(matrix M, int p, int q)
{
    int m = nrows(M);
    int n = ncols(M);
    int i,j;
    matrix MM[m-1][n-1];
    list tmp_list;
    intvec tmp_vec,r,c;
    matrix e[1][1];
    
    e = 1/M[p,q];
    
    tmp_vec = 1..m;
    tmp_list = list(tmp_vec[1..size(tmp_vec)]);
    tmp_list = delete(tmp_list,p);

    for (i=1;i<=size(tmp_list);i++)
    {
        r[i]=tmp_list[i];
    }

    tmp_vec = 1..n;
    tmp_list = list(tmp_vec[1..size(tmp_vec)]);
    tmp_list = delete(tmp_list,q);

    for (i=1;i<=size(tmp_list);i++)
    {
        c[i]=tmp_list[i];
    }
    
    matrix pivotCol[m-1][1] = submat(M,r,q);
    matrix pivotRow[1][n-1] = submat(M,p,c);
    
    // MM = submat(M,r,c) - 1/M[p,q]*submat(M,r,q)*submat(M,p,c);

    // Changed this to cater the non-commutative case.
    // MM = submat(M,r,c) - 1/M[p,q]*pivotCol*pivotRow;
    MM = submat(M,r,c) - pivotCol*e*pivotRow;

    return(MM, pivotCol*e, e*pivotRow);    
    // return(MM);
}

/////////////////////////////////////
// Does a iterative cleanup of the given matrix, until there are no
// units in the matrix.
//
// INPUT: mxn matrix with at least one entry 1
//
// OUTPUT: A list 
// 1. cleaned up matrix without any units
// 2. a list of column numbers which were deleted during the proc. 
//
// Warning: The above list may contain repeated numbers. It just means
// that first you delete lst_rows_deleted[1] column from Identity
// matrix, then delete lst_rows_deleted[2] column from the resulting
// matrix and so on.
//
// Warning 2: In case of any change in the output format, inform
// Mohamed IMMEDIATELY. The GAP code depends on this output.
//
// Warning 3: Suppose at some iteration M is just a column matrix and
// get_uni_pos returns nontrivial answer, then this proc returns a
// string "The output is an empty matrix." BE CAREFUL WHILE CALLING
// THIS PROC.
//
// The worst case example: try to cleanup a matrix with all entries to
// be unit.
/////////////////////////////////////
proc complete_cleanup(matrix M)
{
    list ij;
    int p,q;
    int IS_CLEAN=0;
    list lst_rows_deleted, lst_cols_deleted,lst_row_num_deleted, lst_col_num_deleted, lst_unit;
    int m,n;
    list l;
    

    while(IS_CLEAN<>1)
    {
        m = nrows(M);
        n = ncols(M);
    
        ij = get_unit_pos(M);
        if (size(ij) == 1)
        {
            // "No cleanup possible";
            // "Returning the original matrix";
            IS_CLEAN=1;
            return(M, lst_row_num_deleted, lst_col_num_deleted, lst_rows_deleted, lst_cols_deleted);
        }
        if (m==1 || n==1)
        {
            return("The output is an empty matrix.");
        }
        p = ij[1];
        q = ij[2];

        lst_row_num_deleted[size(lst_row_num_deleted)+1] = p;
        lst_col_num_deleted[size(lst_col_num_deleted)+1] = q;
        
        // No need to divide by the unit here, as it is already being
        // taken care of in the return value of cleanup()
        
        // lst_rows_deleted[size(lst_rows_deleted)+1] = 1/M[p,q]*submat(M,1..m,q);
        // lst_cols_deleted[size(lst_cols_deleted)+1] = 1/M[p,q]*submat(M,p,1..n);

        l = cleanup(M,p,q);
        M = l[1];
        lst_cols_deleted[size(lst_cols_deleted)+1] = -l[2];
        lst_rows_deleted[size(lst_rows_deleted)+1] = -l[3];     
    }
}



/////////////////////////////////////
// Deletes i-th row of the matrix M and returns the submatrix.
/////////////////////////////////////
proc delete_i_th_row(matrix M, int i)
{
    int m = nrows(M);
    int n = ncols(M);
    list tmp_list;
    intvec r, tmp_vec;
    int j;
    
    tmp_vec = 1..m;
    tmp_list = list(tmp_vec[1..size(tmp_vec)]);
    tmp_list = delete(tmp_list,i);

    for (j=1;j<=size(tmp_list);j++)
    {
        r[j]=tmp_list[j];
    }
    return(submat(M,r,1..n));
}



/////////////////////////////////////
// This proc gives the isomorphism matrix by deleting the
// corresponding columns from the identity matrix. The list
// lst_rows_deleted tells (sequentially) which columns are to be
// deleted.  
// 
// Warning: The above list may contain repeated numbers. It just means
// that first you delete lst_rows_deleted[1] column from I, then
// delete lst_rows_deleted[2] column from the result and so on.  
//
// The second parameter n is the number of columns of the original
// matrix.
//
// Warning: Should not be called if cleanup has returned an empty
// matrix. In that case isomorphism matrix is also an empty matrix.
/////////////////////////////////////
proc isomorphism_matrix_new_to_old(list lst_row_num_deleted, int n)
{
    matrix UI = unitmat(n);
    int i;

    for (i=1;i<=size(lst_row_num_deleted);i++)
    {
        UI = delete_i_th_row(UI,lst_row_num_deleted[i]);
    }
//    return(transpose(M));
    return(UI);
}

////////////////////////////////////
// This proc gives the isomorphism from old module to the new
// module. Returns the matrix U such that UM = N, where M is the
// original matrix and N is the cleanup of M. 
// 
// Note that this means the column space generated by UM is same as
// column space generated by N.
//
// The inverse isomorphism is gen by UI, which can be obtained by
// deleting apropriate rows from the identity matrix using proc
// isomorphism_matrix_new_to_old.
//
// m = nrows of the original matrix
////////////////////////////////////
proc isomorphism_matrix_old_to_new(list lst_row_num_deleted, list lst_col_num_deleted, list lst_cols_deleted, int m)
{
    matrix id = unitmat(1);
    int i,j;
    intvec v,w;
    list lst_id_mat;

    for(i=1;i<=size(lst_col_num_deleted);i++)
    {
        id=unitmat(m-i+1);
        id = delete_i_th_row(id,lst_row_num_deleted[i]);
        
        for(j=1;j<=nrows(lst_cols_deleted[i]);j++)
        {
            id[j,lst_row_num_deleted[i]] = lst_cols_deleted[i][j,1];
        }
        lst_id_mat[i] = id;
    }
    matrix U = unitmat(m);
    for (i=1;i<=size(lst_id_mat);i++)
    {
        U = lst_id_mat[i] * U;
    }
    return(U);
}



//////////////////////////////////
// This generates n x n unimodular matrix with random entries.
//////////////////////////////////
proc generate_random_unimod_matrix(int n)
{
    int i,j;
    matrix M[n][n];
    
    for (i=1;i<=n;i++)
    {
        M[i,i] = random(1,10);// sparsepoly(0,0,0,3);
    }
    for (i=1;i<=n;i++)
    {
        for (j=1;j<i;j++)
        {
            M[i,j] = sparsepoly(0,1,75,3);
        }
    }
    
    return(transpose(M)*M);
}



////////////////////////////////
// Input: mxn matrix M, 
//
// Output: int i, int j such that (n-1)-elements of j-th column,
// namely all elements except [i,j]-th entry generate 1 and the ideal
// row_id generated by these (n-1) elements.
////////////////////////////////
proc find_column_except_1_elt_generate_unit(matrix M)
{
    int i,j,t;
    int m,n;
    m = nrows(M);
    n = ncols(M);

    intvec v,w;
    list l;
    ideal column_id;
    
    for (j=1;j<=m;j++)          // Column No.
    {
        for (i=1;i<=n;i++)      // Row No.
        {
            v = 1..m;
            l = list(v[1..m]);
            l = delete(l,i);
            for (t=1;t<=size(l);t++)
            {
                w[t]=l[t];
            }
            
            column_id = ideal(submat(M,w,j));
            // column_id = std(column_id); // These two steps are needed as I
            //                       // am not sure whether std bit is
            //                       // set properly if you combine the
            //                       // two steps. (Ref: Singular trac
            //                       // tkt 428)
            if (reduce(1,std(column_id)) == 0)
            {
                return(i, j, column_id);
            }
        }
    }
    return("The matrix is not unimodular.");
}



////////////////////////////////
// Input: mxn matrix M, int i, int j such that (n-1)-elements of j-th
// column, namely all elements except [i,j]-th entry generate the unit
// matrix.
//
// Output: Matrix of transformation W, such that W*j-th column of M
// makes 1 in (i,j)-th position.
////////////////////////////////

proc column_except_1_elt_generate_unit(matrix M, int i, int j, ideal column_ideal)
{
    int k,l;
    int n = ncols(M);
    
    matrix W = unitmat(n);
    matrix G = rightInverse(matrix(column_ideal)); // Need to compute right
                                           // inverse irrespective of
                                           // row or column
                                           // proc. Since typecast
                                           // from ideal to matrix
                                           // gives a row of which we
                                           // are finding right inverse.
    if (i == 1)
    {
        W[j,i]=1;
        
        for (k=2;k<=n;k++)
        {
            W[j,k] = (1-M[i,j])*G[k-1,1];
        }
        return(W);
    }

    if (i == n)
    {
        W[j,i]=1;
        for (k=1;k<=n-1;k++)
        {
            W[j,k] = (1-M[i,j])*G[k,1];
        }
        return(W);
    }
    for (k=1;k<i;k++)
    {
        W[j,i]=1;
        if (k<i)
            W[j,k] = (1-M[i,j])*G[k,1];
    }
    for (k=1;k>i;k++)
    {
        W[j,i]=1;
        W[j,k] = (1-M[i,j])*G[k-1,1];
    }
    return(W);
}


////////////////////////////////
// Input: mxn matrix M, 
//
// Output: int i, int j such that (n-1)-elements of i-th row, namely
// all elements except [i,j]-th entry generate the unit matrix and the
// ideal row_id generated by these (n-1) elements.
//
////////////////////////////////

proc find_row_except_1_elt_generate_unit(matrix M)
{
    int i,j,t;
    int m,n;
    m = nrows(M);
    n = ncols(M);
    
    intvec v,w;
    list l;
    ideal row_id;
    
    for (i=1;i<=n;i++)      // Row No.
    {
        for (j=1;j<=m;j++)          // Column No.
        {
            v = 1..n;
            l = list(v[1..n]);
            l = delete(l,j);
            for (t=1;t<=size(l);t++)
            {
                w[t]=l[t];
            }
            row_id = ideal(submat(M,i,w));

            if (reduce(1,std(row_id)) == 0)
            {
                return(i, j, row_id);
            }
        }
    }
    return("The matrix is not unimodular.");
}



////////////////////////////////
// Input: mxn matrix M, int i, int j such that (n-1)-elements of i-th
// row, namely all elements except [i,j]-th entry generate the unit
// matrix.
//
////////////////////////////////

proc row_except_1_elt_generate_unit(matrix M, int i, int j, ideal row_ideal)
{
    int k,l;
    int m = nrows(M);
    
    matrix W = unitmat(m);
    matrix G = rightInverse(matrix(row_ideal)); // Need to compute right
        // inverse irrespective of
        // row or column
        // proc. Since typecast
        // from ideal to matrix
        // gives a row of which we
        // are finding right inverse.
    
    if (i == 1)
    {
        W[j,i]=1;

        for (k=2;k<=m;k++)
        {
            W[k,i] = G[k-1,1]*(1-M[i,j]);
        }
        return(W);
    }

    if (i == n)
    {
        W[j,i]=1;
        for (k=1;k<=m-1;k++)
        {
            W[k,i] = G[k,1]*(1-M[i,j]);
        }
        return(W);
    }
    for (k=1;k<j;k++)
    {
        W[j,i]=1;
        W[k,i] = G[k,1]*(1-M[i,j]);
    }
    for (k=1;k>j;k++)
    {
        W[j,i]=1;
        W[k,i] = G[k-1,1]*(1-M[i,j]);
    }
    return(W);
}



///////////////////////////////
// Given a matrix M, this proc finds a column which has left inverse
// containing a unit.
//
// Anna's thesis Heuristic 2.2.2(1)
//
// INPUT: Matrix M
//
// OUTPUT: int i, int j, matrix W such that i-th entry of a left
// inverse of j-th column of M is a unit. W is the matrix of
// transformation such that W*M has 1 in (i,j)-th position.
///////////////////////////////
proc column_having_left_inverse_containing_unit(matrix M)
{
    int m = nrows(M);
    int n = ncols(M);
    int i,j,k;
    matrix ltInv[1][n];
    matrix W = unitmat(n);
    
    
    for (j=1;j<=n;j++)
    {
        ltInv = leftInverse(submat(M,1..m,j));
        if (ltInv != 0)
        {
            for (i=1;i<=m;i++)
            {
                if (deg(ltInv[1,i]) == 0)
                {
                    for (k=1;k<=n;k++)
                    {
                        W[i,k] = ltInv[1,k];
                    }
                    return(i, j, W);
                }
            }
        }
    }
    return("Matrix has no column having left inverse containing a unit.");
}

///////////////////////////////
// Given a matrix M, this proc finds a row which has right inverse
// containing a unit.
//
// INPUT: Matrix M
//
// OUTPUT: int i, int j, matrix W such that j-th entry of a right
// inverse of i-th row of M is a unit. W is the matrix of
// transformation such that W*M has 1 in (i,j)-th position.
///////////////////////////////
proc row_having_right_inverse_containing_unit(matrix M)
{
    int m = nrows(M);
    int n = ncols(M);
    int i,j,k;
    matrix rtInv[1][n];
    matrix W = unitmat(n);
    
    
    for (i=1;i<=m;i++)
    {
        rtInv = rightInverse(submat(M,i,1..n));
        if (rtInv != 0)
        {
            for (j=1;j<=n;j++)
            {
                if (deg(rtInv[j,1]) == 0)
                {
                    for (k=1;k<=m;k++)
                    {
                        W[k,j] = rtInv[k,1];
                    }
                    return(i, j, W);
                }
            }
        }
    }
    return("Matrix has no column having left inverse containing a unit.");
}



//////////////////////////////////////////////////
// Input: poly f of degree s and poly g of degree <= s-1
// int var_pos is the position of the variable wrt which SuslinLemma is applied.
// int unit_pos is the unit_pos-th coefficients of g is a unit.
//
// Assumption:the poly g is given by: b_0+b_1y+...+b_(s-1)y^(s-1) and
// unit_pos=j+1 such that b_j=coeff of y^j is a unit in the ring B,
// where B is a subring of the basering without (var_pos)-th variable.
//
// Returns a poly g' of degree <= s-1, whose leading coefficient is
// this unit and the matrix W of transformation.
//
// Ref: Lemma 4.97 in Rotman
//////////////////////////////////////////////////

// proc Suslin_Lemma_from_GAP(poly f, poly g, int var_pos, int unit_pos)
proc Suslin_Lemma(poly f, poly g, int var_pos, int unit_pos)
{
    int i,j;
    poly h, cp, cq;
    poly var_poly = var(var_pos);
    int s,d,t,k;    
    matrix F[1][2] = f,g;

    intvec v;
    v[nvars(basering)] = 0;
    v[var_pos] = 1;


    s = deg(f,v);
    t = deg(g,v);    

    if (s<=t)
    {
        ERROR("The polynomial f should be of higher degree than g.");
    }
    if (unit_pos > t)
    {
        ERROR("The position of unit should be between 0 and degree of g.");
    }
    if (unit_pos < 0)
    {
        ERROR("The position of unit should be between 0 and degree of g.");
    }
    
    matrix A = coeffs(f,var_poly);

    if(A[size(A),1] != 1)
    {
        ERROR("The poly f should be monic.");
    }

    if (unit_pos == t)
    {
        "Nothing to do.";
        return(g,0,1);
    }
    matrix B = coeffs(g,var_poly);
    if (B[unit_pos + 1,1] == 0)
    {
        // h = 0;
        // cp = 0;
        // cq = 0;
        return(0,0,0);
    }
    A = submat(A, (unit_pos+1)+1 .. s+1, 1);

    B = submat(B, (unit_pos+1)+1 .. t+1, 1);
    
    matrix YA [1][size(A)];
    
    for (i=1;i<=s-(unit_pos+1)+1;i++)
    {
        YA[1,i] = var_poly^(i-1);
    }
    
    matrix cp_mat = YA*A;
    cp = cp_mat[1,1];
    
    if (t == unit_pos)
    {
        cq = 0;
    }
    else
    {        
        matrix YB[1][t-unit_pos];
        
        for (i=0;i<=t-(unit_pos+1);i++)
        {
            YB[1,i+1] = var_poly^i;
        }
        matrix cq_mat = YB*B;
        cq = - cq_mat[1,1];
        
    }
    return(cq*f+cp*g,cp,cq);
}




////////////////////////////////////////////////////
// INPUT: poly f, maximal id max_id and int var_pos such that max_id
// is maximal in the subring without the variable var(var_pos).
//
// OUTPUT: 1 if f is a unit in the localization of this subring wrt
// the given max ideal, 0 otherwise.
//
// ASSUMPTION: 1. max_id is maximal in the above mentioned subring.
// 2. f is an element in this subring.
// 3. The original ring has AT_LEAST 2 variable... (NEED TO CHANGE THIS LATER)
////////////////////////////////////////////////////
proc is_local_unit(poly f, ideal max_id, int var_pos)
{
    string old_ring_name = nameof(basering);

    int i,j;
    string new_var_str;
    int n = nvars(basering);
    
    for (i=1;i<n;i++) // Special for the last var.
    {
        if (i != var_pos)
        {
            new_var_str = new_var_str + string(var(i))+", ";
        }
    }
    if (var_pos != n)
    {
        new_var_str = new_var_str + string(var(n));
    }
    
    execute("ring tmpR = ("+charstr(basering)+"),("+new_var_str+"),("+ordstr(basering)+")");
    execute("poly f = imap("+old_ring_name+",f)");
    execute("ideal m = imap("+old_ring_name+",max_id)");

    m = std(m);
    if (reduce(f,m) != 0)
    {
        return(1);
    }
    else
    {
        return(0);
    }
}


////////////////////////////////////////////
// Returns a maximal ideal of the ring k[lst_vars] containing the
// ideal I. The list of variables is given as an intvec v such that
// lst_vars[i] = var(v[i]).
////////////////////////////////////////////

proc get_max_ideal(ideal I, intvec v)
{
    int i,j;
    string chr_str = charstr(basering);
    string s, new_var_str;
    
    ideal max_id;
    
    
    for(i=1;i<size(v);i++)
    {
        new_var_str = new_var_str + string(var(v[i])) + ", ";
    }
    if(i>2)
    {
        new_var_str = new_var_str + string(var(v[i]));
    }
    
    if (find("integer",chr_str) != 0)
    {
        s = "ring tmp_ring_int = ("+chr_str+"), ("+new_var_str+"), ("+ordstr(basering)+")";
        max_id = get_max_ideal_integers(I,s);
    }
    else
    {
        if(char(basering) == 0) // All fields of char 0
        {
            s = "ring tmp_ring_0 = ("+chr_str+"), ("+new_var_str+"), ("+ordstr(basering)+")";
            max_id = get_max_ideal_char_zero(I,s);
        }
        else
        {
            s = "ring tmp_ring_p = ("+chr_str+"), ("+new_var_str+"), ("+ordstr(basering)+")";
            max_id = get_max_ideal_char_p(I,s);
        }
    }
    return(max_id);
    
}

// This is an internal proc, not for public.
//
// ideal I is in the original ring; string s contains the string to be
// executed to define a new ring.

proc get_max_ideal_integers(ideal I,string s)
{
    def old_ring = basering;
    
    int i,c;
    intvec vec_indep_var;
    
    execute(s);                 // This sets the basering to tmp_ring;
    ideal indep_var_id;
    
    ideal new_I = fetch(old_ring,I);
    ideal max_id;    
    new_I = std(new_I);
    ideal n;
    int not_one = 0;
    
               
    if (new_I == 0)
    {
        max_id = 2,maxideal(1);
        setring(old_ring);
        return(fetch(tmp_ring_int, max_id));
    }

    int prime_factor = 2;
    int const_gen = 0;
    list prime_list;
    

    for (i=1;i<=size(new_I);i++)
    {
        if (deg(new_I[i]) == 0) // i.e. i-th generator is an integer.
        {
            const_gen = new_I[i];            
            break;
        }
    }
    if(const_gen != 0)
    {
        prime_factor = primefactors(new_I[i])[1][1];
    }
    else
    {
        while(reduce(1,std(new_I,prime_factor)) == 0)
        {
            // prime_factor++;
            prime_list=primList(2*prime_factor);
            prime_factor = prime_list[1];
        }
    }

    string str = "ring tmp_ring_p = ("+string(prime_factor)+"), ("+varstr(tmp_ring_int)+"), ("+ordstr(tmp_ring_int)+")";
    max_id = get_max_ideal_char_p(new_I,str), prime_factor;
    setring(old_ring);
    ideal m = fetch(tmp_ring_int, max_id);
    return(m);
}




// This is an internal proc, not for public.
//
// ideal I is in the original ring; string s contains the string to be
// executed to define a new ring.

proc get_max_ideal_char_zero(ideal I,string s)
{
    def old_ring = basering;
        
    int i,c;
    intvec vec_indep_var;

    execute(s);                 // This sets the basering to tmp_ring;
    ideal indep_var_id;
    
    ideal new_I = fetch(old_ring,I);

    ideal max_id;    
    new_I = std(new_I);
    ideal n;
    int not_one = 0;
    
    if (new_I == 0)
    {
        max_id = maxideal(1);
        setring(old_ring);
        return(fetch(tmp_ring_0, max_id));
    }
    while (dim(std(new_I)) > 0)
    {
        vec_indep_var = indepSet(std(new_I));
        
        for (i=1;i<=nvars(basering);i++)
        {
            if(vec_indep_var[i] == 1)
            {
                indep_var_id = indep_var_id, var(i);
            }
        }

        while (1)
        {
            n = new_I,indep_var_id;
            if (reduce(1,std(n)) != 0)
            {
                not_one = 1;
                break;
            }
            if(size(indep_var_id)>1)
            {
                indep_var_id = indep_var_id[1..size(indep_var_id)-1];
            }
        }
        
        if(not_one == 1)
        {
            new_I = n;
        }
        else
        {
            c=1;
            while(reduce(1,std(new_I,indep_var_id[1]+c)) == 0)
            {
                c++;
            }
            new_I = std(new_I,indep_var_id[1]+c);
        }
    }

    list min_ass_pr = minAssGTZ(new_I);
    max_id = min_ass_pr[1];

    setring(old_ring);
    ideal m = fetch(tmp_ring_0, max_id);
    return(m);
}



// This is an internal proc, not for public.
//
// ideal I is in the original ring; string s contains the string to be
// executed to define a new ring.

proc get_max_ideal_char_p(ideal I,string s)
{
    def old_ring = basering;
        
    int i,c,k;
    intvec vec_indep_var;
    
    execute(s);                 // This sets the basering to tmp_ring;
    ideal indep_var_id;
    
    ideal new_I = fetch(old_ring,I);

    ideal max_id;    
    new_I = std(new_I);
    ideal n;
    int not_one = 0;
    

    if (new_I == 0)
    {
        max_id = maxideal(1);
        setring(old_ring);
        return(fetch(tmp_ring_p, max_id));
    }
    while (dim(std(new_I)) > 0)
    {
        vec_indep_var = indepSet(std(new_I));
        
        for (i=1;i<=nvars(basering);i++)
        {
            if(vec_indep_var[i] == 1)
            {
                indep_var_id = indep_var_id, var(i);
            }
        }

        while (1)
        {
            n = new_I,indep_var_id;
            if (reduce(1,std(n)) != 0)
            {
                not_one = 1;
                break;
            }
            if(size(indep_var_id)>1)
            {
                indep_var_id = indep_var_id[1..size(indep_var_id)-1];
            }
        }
        
        if(not_one == 1)
        {
            new_I = n;
        }
        else
        {
            c=1;
            k=1;
            while(reduce(1,std(new_I,indep_var_id[1]^k+c)) == 0)
            {
                c++;
                if (c == char(basering))
                {
                    k++;
                    c=0;
                }
            }
            new_I = std(new_I,indep_var_id[1]+c);
        }
    }

    list min_ass_pr = minAssGTZ(new_I);
    max_id = min_ass_pr[1];

    setring(old_ring);
    ideal m = fetch(tmp_ring_p, max_id);
    return(m);
}
