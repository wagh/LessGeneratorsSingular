LIB "matrix.lib";
LIB "control.lib";

///////////////////////////////////////
// Returns the size of a matrix 
// in the format: "r x c"
// Warning: The output is a string.
///////////////////////////////////////
proc size_matrix(matrix M)
{
    if (typeof(M) <> "matrix")
    {
        return("Use size function\n The input should be of the type matrix");
    }
    return(string(nrows(M))+" x "+string(ncols(M)));
}


///////////////////////////////////////
// Module M is a rank 1 projective module.
// M is given by (n-1)xn matrix
//
// The procedure a returns a row which gives an isomorphism from the
// cokernel of the given matrix (i.e. rank 1 proj modules generated by
// n non-free generators) to the free module of rank 1. The right
// inverse of this row is the matrix of inverse isomorphism or
// equivalently the free generator of the corresponding free module.
///////////////////////////////////////
proc CauchyBinetRow(matrix M)
{
    int n = nrows(M);
    int i;
    intvec v,w;
    matrix M_i[n-1][n-1];
    matrix CB_completion[1][n];

    w = 1..n-1;

// For i = 1
    v = 2..n;
    M_i = submat(M,v,w);
    CB_completion[1,1] = (-1)^(n+1)*det(M_i);

// For i = n
    v = 1..n-1;
    M_i = submat(M,v,w);
    CB_completion[1,n] = (-1)^(n+n)*det(M_i);

// For 1<i<n    
    for (i=2;i<n;i++)
    {
        v = 1..i-1,i+1..n;
        M_i = submat(M,v,w);
        CB_completion[1,i] = (-1)^(n+i)*det(M_i);
    }
    
    return(CB_completion);
}
