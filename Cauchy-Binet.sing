LIB "matrix.lib";
LIB "control.lib";
// LIB "random.lib";

///////////////////////////////////////
// Returns the size of a matrix 
// in the format: "r x c"
// Warning: The output is a string.
///////////////////////////////////////
proc size_Matrix(matrix M)
{
    if (typeof(M) <> "matrix")
    {
        return("Use size function\n The input should be of the type matrix");
    }
    return(string(nrows(M))+" x "+string(ncols(M)));
}


///////////////////////////////////////
// Module M is a rank 1 projective module.
// M is given by (n-1)xn matrix
//
// The procedure a returns a row which gives an isomorphism from the
// cokernel of the given matrix (i.e. rank 1 proj modules generated by
// n non-free generators) to the free module of rank 1. The right
// inverse of this row is the matrix of inverse isomorphism or
// equivalently the free generator of the corresponding free module.
///////////////////////////////////////
proc CauchyBinetRow(matrix M)
{
    int n = nrows(M);
    int i;
    intvec v,w;
    matrix M_i[n-1][n-1];
    matrix CB_completion[1][n];

    w = 1..n-1;

// For i = 1
    v = 2..n;
    M_i = submat(M,v,w);
    CB_completion[1,1] = (-1)^(n+1)*det(M_i);

// For i = n
    v = 1..n-1;
    M_i = submat(M,v,w);
    CB_completion[1,n] = (-1)^(n+n)*det(M_i);

// For 1<i<n    
    for (i=2;i<n;i++)
    {
        v = 1..i-1,i+1..n;
        M_i = submat(M,v,w);
        CB_completion[1,i] = (-1)^(n+i)*det(M_i);
    }
    
    return(CB_completion);
}


ring R = 0,(x,y),dp;
matrix m[3][2];


//  4/125,  -64/5*x+384/25*y+2152/125,      8/25*y+4/125,    
// -21/250,168/5*x-1008/25*y-5524/125,     -21/25*y-21/250, 
// 504/125,-8064/5*x+48384/25*y+271152/125,1008/25*y+629/125

m = -64/5*x+384/25*y+2152/125,      8/25*y+4/125,
    168/5*x-1008/25*y-5524/125,     -21/25*y-21/250, 
    -8064/5*x+48384/25*y+271152/125,1008/25*y+629/125;

matrix tmpA[3][3];
matrix tmpB[3][3];
tmpA = 1,sparsepoly(5),sparsepoly(5),
    0,1,sparsepoly(5),
    0,0,1;
tmpB = 1,0,0,
    sparsepoly(5),1,0,
    sparsepoly(5),sparsepoly(5),1;
m=tmpA*tmpB;
m = submat(m,1..3,1..2);
print(m);

"size of m = "+size_Matrix(m);
"------";


matrix ltInv[2][3] = leftInverse(m);
matrix CBRow[1][nrows(m)] = CauchyBinetRow(m);
matrix B[nrows(m)][nrows(m)] = transpose((concat(transpose(ltInv),transpose(CBRow))));

///////////////////////////////////////
// Given a (column) unimodular matrix A, this first computes the left inverse
// of A, then completes it to a square matrix and then right inverse of
// this is precisely the column completion of A.
///////////////////////////////////////
matrix uni_completion = rightInverse(B);

print(uni_completion);
"size of uni_completion = "+size_Matrix(uni_completion);
"";
"Determinent  = "+string(det(uni_completion));

