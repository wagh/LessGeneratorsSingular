LIB "control.lib";

//////////////////////////////////
// This generates n x n unimodular matrix with random entries.
//////////////////////////////////
proc generate_random_unimod_matrix(int n)
{
    int i,j;
    matrix M[n][n];
    
    for (i=1;i<=n;i++)
    {
        M[i,i] = random(1,10);// sparsepoly(0,0,0,3);
    }
    for (i=1;i<=n;i++)
    {
        for (j=1;j<i;j++)
        {
            M[i,j] = sparsepoly(0,1,75,3);
        }
    }
    return(transpose(M)*M);
}



////////////////////////////////
// Input: mxn matrix M, 
//
// Output: int i, int j such that (n-1)-elements of j-th column,
// namely all elements except [i,j]-th entry generate 1 and the ideal
// row_id generated by these (n-1) elements.
////////////////////////////////
proc find_column_except_1_elt_generate_unit(matrix M)
{
    int i,j,t;
    int m,n;
    m = nrows(M);
    n = ncols(M);

    intvec v,w;
    list l;
    ideal column_id;
    
    for (j=1;j<=m;j++)          // Column No.
    {
        for (i=1;i<=n;i++)      // Row No.
        {
            v = 1..m;
            l = list(v[1..m]);
            l = delete(l,i);
            for (t=1;t<=size(l);t++)
            {
                w[t]=l[t];
            }
            
            column_id = ideal(submat(M,w,j));

            if (reduce(1,std(column_id)) == 0)
            {
                return(i, j, column_id);
            }
        }
    }
    return("The matrix is not unimodular.");
}


////////////////////////////////
// Input: mxn matrix M, 
//
// Output: int i, int j such that (n-1)-elements of i-th row, namely
// all elements except [i,j]-th entry generate the unit matrix and the
// ideal row_id generated by these (n-1) elements.
//
////////////////////////////////

proc find_row_except_1_elt_generate_unit(matrix M)
{
    int i,j,t;
    int m,n;
    m = nrows(M);
    n = ncols(M);
    
    intvec v,w;
    list l;
    ideal row_id;
    
    for (i=1;i<=n;i++)      // Row No.
    {
        for (j=1;j<=m;j++)          // Column No.
        {
            v = 1..n;
            l = list(v[1..n]);
            l = delete(l,j);
            for (t=1;t<=size(l);t++)
            {
                w[t]=l[t];
            }
            
            row_id = ideal(submat(M,i,w));

            if (reduce(1,std(row_id)) == 0)
            {
                return(i, j, row_id);
            }
        }
    }
    return("The matrix is not unimodular.");
}


////////////////////////////////
// Input: mxn matrix M, int i, int j such that (n-1)-elements of j-th
// column, namely all elements except [i,j]-th entry generate the unit
// matrix.
//
// Output: Matrix of transformation W, such that W*j-th column of M
// makes 1 in (i,j)-th position.
////////////////////////////////

proc column_except_1_elt_generate_unit(matrix M, int i, int j, ideal column_ideal)
{
    int k,l;
    int n = ncols(M);
    
    matrix W = unitmat(n);
    matrix G = rightInverse(matrix(column_ideal)); // Need to compute right
        // inverse irrespective of
        // row or column
        // proc. Since typecast
        // from ideal to matrix
        // gives a row of which we
        // are finding right inverse.
    if (i == 1)
    {
        W[j,i]=1;
        
        for (k=2;k<=n;k++)
        {
            W[j,k] = (1-M[i,j])*G[k-1,1];
        }
        return(W);
    }

    if (i == n)
    {
        W[j,i]=1;
        for (k=1;k<=n-1;k++)
        {
            W[j,k] = (1-M[i,j])*G[k,1];
        }
        return(W);
    }
    for (k=1;k<i;k++)
    {
        W[j,i]=1;
        if (k<i)
            W[j,k] = (1-M[i,j])*G[k,1];
    }
    for (k=1;k>i;k++)
    {
        W[j,i]=1;
        W[j,k] = (1-M[i,j])*G[k-1,1];
    }
    return(W);
}


////////////////////////////////
// Input: mxn matrix M, int i, int j such that (n-1)-elements of i-th
// row, namely all elements except [i,j]-th entry generate the unit
// matrix.
//
////////////////////////////////

proc row_except_1_elt_generate_unit(matrix M, int i, int j, ideal row_ideal)
{
    int k,l;
    int m = nrows(M);
    
    matrix W = unitmat(m);
    matrix G = rightInverse(matrix(row_ideal)); // Need to compute right
        // inverse irrespective of
        // row or column
        // proc. Since typecast
        // from ideal to matrix
        // gives a row of which we
        // are finding right inverse.

    if (j == 1)
    {
        W[j,i]=1;

        for (k=2;k<=m;k++)
        {
            W[k,i] = G[k-1,1]*(1-M[i,j]);
        }
        return(W);
    }
    else
    {
        if (j == n)
        {
            W[j,i]=1;
            for (k=1;k<=m-1;k++)
            {
                W[k,i] = G[k,1]*(1-M[i,j]);
            }
            return(W);
        }
        else
        {
            for (k=1;k<j;k++)
            {
                W[j,i]=1;
                W[k,i] = G[k,1]*(1-M[i,j]);
                // "W[",k,",",i,"] = ",G[k,1],"*(1-",M[i,j],")";
            }
            for (k=j+1;k<=n;k++)
            {
                W[j,i]=1;
                W[k,i] = G[k-1,1]*(1-M[i,j]);
                // "W[",k,",",i,"] = ",G[k-1,1],"*(1-",M[i,j],")";
            }
            return(W);
        }
    }
}


